
<!DOCTYPE html>
<!-- Copyright (c) 2014 Amber Roy -->
<!-- For more info see homepage at http://VRplanetchase.com -->
<html lang="en">
<head>
  <title>VR Planet Chase - WebVR Game</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
  body {
    background:#fff;
    padding:0;
    margin:0;
    font-weight: bold;
    overflow:hidden;
  }
  #container {
    /* no styling yet */
  }
</style>

  <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
  <!-- for rendering to Oculus Rift -->
  <script src="js/VREffect.js"></script>
  <script src="js/VRControls.js"></script>
  <!-- for rendering to Google Cardboard -->
  <!-- this version of StereoEffect modified slightly: reset renderer.autoClear -->
  <script src="js/StereoEffect.js"></script>
  <script src="js/DeviceOrientationControls.js"></script>

  <!-- for Leap Motion controller -->
  <script src="http://js.leapmotion.com/leap-0.6.3.min.js"></script>
  <script src="http://js.leapmotion.com/leap-plugins-0.1.9.min.js"></script>

</head>

<body oncontextmenu="return false;">
  <table><tr>
  <td><button onclick="launchVR();"><h3>Enter VR Mode</h3></button></td>
  <td><button onclick="launchCardboard();"><h3>Cardboard Mode</h3></button></td>
  </tr></table>
  <div id="container">
  </div>
</body>

<script>

var modes = Object.freeze ({
  noVR: "noVR",   // default when page is loaded
  webVR: "webVR", // requires VR-enabled browser
  cbVR: "cbVR"    // Google cardboard for Android
});
var renderMode = modes.noVR; 
var pendingMode = null;

var camera, scene, renderer;
var winRenderWidth = 640; // window.innerWidth;
var winRenderHeight = winRenderWidth * (1080/1920); // window.innerHeight;
var renderWidth = winRenderWidth;
var renderHeight = winRenderHeight;

var gameObjects;
var mouseDownIntervalID = -1;
var redPlanet;
var isRedPlanetFound = false;
var asteroidsArray;

var asteroidMaterial;
var redPlanetMaterial;
var redPlaentFoundMaterial;
var asteroidCollisionMaterial;

var vrControls, vrEffect;
var cbControls, cbEffect;
var clock = new THREE.Clock();
var autoMoveForward = true;
var iOS = ['iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) >= 0;

var ZERO_VECTOR3 = Object.freeze(new THREE.Vector3(0,0,0));
var headPosition = ZERO_VECTOR3;

//---------------------------------------------------------------------------
// Game Objects
//---------------------------------------------------------------------------

function initScene() {
  // Initialize the scene with camera, light, and game objects.  

  camera = new THREE.PerspectiveCamera( 60, renderWidth / renderHeight, 1, 10000 );
  camera.position.z = 500;

  scene = new THREE.Scene();

  // Need light source with phong material, otherwise spheres look black.
  var pointerOne = new THREE.PointLight(0xffffff);
  pointerOne.position.set(-100,-90,130);
  scene.add(pointerOne);

  createGameObjects();

  renderer = new THREE.WebGLRenderer( { alpha: true } );
  renderer.setClearColor( 0xffffff ); 
  renderer.setSize(renderWidth, renderHeight);
  renderer.domElement.setAttribute("id", "three_canvas");
  container.appendChild( renderer.domElement );
}

function createGameObjects() {
  // Create the game world objects and randomize their position.

  // For random color: Math.floor(Math.random() * 0x1000000
  var COLOR_BLUE = 0x0000ff;
  var COLOR_RED = 0xff0000;
  var COLOR_GRAY = 0x808080;
  var COLOR_GOLD = 0xFFD700;
  var NUM_ASTEROIDS = 200;

  // Use sphere with shiny phong material, requries a light source.
  // SphereGeometry params: radius, widthSegments, heightSegments
  // Phong params: color, specular(color), shininess
  var geometry = new THREE.SphereGeometry( 50, 16, 16);
  asteroidMaterial = new THREE.MeshPhongMaterial({ color: COLOR_GRAY });
  redPlanetMaterial = new THREE.MeshPhongMaterial({ color: COLOR_RED });
  redPlaentFoundMaterial = new THREE.MeshPhongMaterial({ color: COLOR_BLUE });
  asteroidCollisionMaterial = new THREE.MeshPhongMaterial({ color: COLOR_GOLD });

  gameObjects = new THREE.Object3D(); // Root of the game objects graph.
  asteroidsArray = [];                // Used for collision detection.

  // Create the asteroids.
  for (var i = 0; i < NUM_ASTEROIDS; i ++) {

    var asteroid = new THREE.Mesh(geometry, asteroidMaterial);
    setRandomPosition(asteroid);

    asteroidsArray.push(asteroid);
    gameObjects.add(asteroid);
  }

  // Create the planet.
  redPlanet = new THREE.Mesh(geometry, redPlanetMaterial);
  setRandomPosition(redPlanet);
  gameObjects.add(redPlanet);

  scene.add(gameObjects);

}

function setRandomPosition(mesh) {
    mesh.position.x = Math.random() * 2000 - 1000;
    mesh.position.y = Math.random() * 2000 - 1000;
    mesh.position.z = Math.random() * 2000 - 1000;
    mesh.rotation.x = Math.random() * 2 * Math.PI;
    mesh.rotation.y = Math.random() * 2 * Math.PI;
    mesh.matrixAutoUpdate = false;
    mesh.updateMatrix();
}

function checkCollision(cameraPosition) {
  // Simple collision detection algorithm.

  var isCollision = false;

  // Check for collision between camera and each asteroid.  
  var asteroidBuffer = 0;
  for (var i = 0; i < asteroidsArray.length; i++) {
    var sphere = asteroidsArray[i];
    var distance = cameraPosition.distanceTo(sphere.position);
    if (distance < sphere.geometry.boundingSphere.radius + asteroidBuffer) {
      isCollision = true;
      console.log("Collision with sphere", i, "radius", sphere.geometry.radius);
      console.log("camera position", cameraPosition);
      console.log("sphere position", sphere.position);

      // Collision effect
      sphere.material = asteroidCollisionMaterial;
      setTimeout(function() {
        sphere.material = asteroidMaterial;
      }, 2000)
      break;
    }
  }

  // For red planet, detect collision when in the buffer zone, before camera
  // collides, so player can see the planet color change.
  var distance = cameraPosition.distanceTo(redPlanet.position);
  var redPlanetBuffer = redPlanet.geometry.boundingSphere.radius * 4;
  if (distance < redPlanet.geometry.boundingSphere.radius + redPlanetBuffer) {
    isCollision = true;
    if (!isRedPlanetFound) {

      // Found it!  Change color.
      isRedPlanetFound = true;
      var millis = 500;
      var blinks = 5;
      redPlanet.material = redPlaentFoundMaterial; 

      // Reset the game. Create new set of asteroids to navigate.
      setTimeout(function() {
        scene.remove(gameObjects);
        createGameObjects();
        isRedPlanetFound = false;
        // We could reset camera here: camera.lookAt(scene.position)
      }, 2000);   // Wait a few seconds before restarting.
    }
  }

  if (isCollision) {
    console.log("Collision detected");
  }
  return isCollision;
}

//---------------------------------------------------------------------------
// Game Controls
//---------------------------------------------------------------------------

function onKeyPress(event) {
  var MOVE_ON_KEY = 25;
  console.log("onKeyPress", event.which)

  switch (event.which) {

  case 'w'.charCodeAt(0):
    // Walk forward
    moveForward(MOVE_ON_KEY * -1);
    break;

  case 's'.charCodeAt(0):
    // Walk backwards
    moveForward(MOVE_ON_KEY);
    break;

  case 13:
    // "Enter" key was pressed
    launchVR();
    break;

  case 'f'.charCodeAt(0):
    launchVR();
    break;

  case 'z'.charCodeAt(0):
    vrControls.zeroSensor();
    break;

  }

}

function moveForward(moveDistance) {

  var movedCamera = camera.clone();
  movedCamera.translateZ(moveDistance);

  // Don't let the camera get too far from center of scene.
  var sceneCenterPosition = ZERO_VECTOR3; 
  var distance = movedCamera.position.distanceTo(sceneCenterPosition); 
  if (distance >= 1500) {
    console.log("Movement stopped, too far from center of scene", distance);
    return;
  }

  if (!checkCollision(movedCamera.position)) {
    camera.translateZ(moveDistance);
  }
}

function onMouseDown(event) {
  // Create timer to repeatedly call method while mouse is down.

  // Using mouse cancels the auto-move in cardboard mode.
  if (renderMode === modes.cbVR && autoMoveForward) {
    autoMoveForward = false;
  }

  if(mouseDownIntervalID == -1) {  // Only create if none exists.
     // Pass event to the function so we know which button is clicked.
     var func = function() { whileMouseDown(event); };
     mouseDownIntervalID = setInterval(func, 100); // every 100ms
   }
}

function onMouseUp(event) {
  // When mouse button released, clear the timer.
   if(mouseDownIntervalID != -1) {  // Only clear if exists.
     clearInterval(mouseDownIntervalID);
     mouseDownIntervalID =- 1;
   }
}

function whileMouseDown(event) {
  // While mouse is down, move the camera forward.
  console.log("mouse button", event.which);

  var MOVE_ON_CLICK = -25;
  switch (event.which) {
    case 1:
      // left click: move forwards
      moveForward(MOVE_ON_CLICK);
      break;
    case 2:
      // middle click
      // Back button on Microsoft mouse also sends this; ignore.
      break;
    case 3:
      // right click: move backwards
      moveForward(MOVE_ON_CLICK * -1);
      break;

    default:  
      // Unrecognized button
  }

}

function onLeapMotionFrame(frame) {

  var move_on_leap = 10;
  leapmotionhandcount = frame.hands.length;
  if (leapmotionhandcount === 1) {
    // one hand: move forward
    console.log("hand count:", leapmotionhandcount);
    moveForward(move_on_leap * -1);
  } else if (leapmotionhandcount === 2) {
    // two hands: move back
    console.log("hand count:", leapmotionhandcount);
    moveForward(move_on_leap);
  }
}

//---------------------------------------------------------------------------
// VR Rendering
//---------------------------------------------------------------------------

function addVRControls() {

  // for web-VR
  vrEffect = new THREE.VREffect(renderer);
  vrControls = new THREE.VRControls(camera);

  // for google cardboard VR
  cbEffect = new THREE.StereoEffect(renderer);
  cbControls = new THREE.DeviceOrientationControls(camera, true); 
  cbControls.connect(); 
  cbControls.update();

  // Connect to the Leap Motion controller, if one is present. 
  var controllerOptions = {}; // none for now
  var leapController = Leap.loop(controllerOptions, onLeapMotionFrame);
  Leap.loopController.use('transform', {vr: true}); // Optimize for HMD mount.

}

function launchVR() {
  pendingMode = modes.webVR;
  vrEffect.setFullScreen(true);
}

function animate() {
  requestAnimationFrame(animate); 
  render();
}

function render() {

  switch(renderMode) {

  case modes.noVR:

    renderer.render(scene, camera);
    break;

  case modes.webVR:

    var cameraPosition = camera.position.clone();
    var lastHeadPosition = headPosition;
    vrControls.update();  // Resets camera to absolute head position from HMD.
    headPosition = camera.position.clone();
    if (headPosition.equals(cameraPosition)) {
      // On Firefox, if no HMD position data, then camera is not reset. Force to zero.
      headPosition = ZERO_VECTOR3;
    }
    // Add any head movement (via positional tracking) to the camera position.
    camera.position.set(cameraPosition.x + (headPosition.x - lastHeadPosition.x),
                        cameraPosition.y + (headPosition.y - lastHeadPosition.y),
                        cameraPosition.z + (headPosition.z - lastHeadPosition.z));
    vrEffect.render(scene, camera);  
    break;

  case modes.cbVR:

    if (autoMoveForward) {
      // Move camera forward continuously.
      moveForward(-1);
    }
    cbControls.update(clock.getDelta);
    cbEffect.render(scene, camera);  
    break;

  default:
    console.log("Unrecognized render mode:", renderMode)

  }
}

//---------------------------------------------------------------------------
// Fullscreen Management
//---------------------------------------------------------------------------

function onFullscreenChange() {

  var fullscreenElement = document.fullscreenElement || 
                          document.mozFullScreenElement || 
                          document.webkitFullscreenElement;

  if (fullscreenElement) {
    if (pendingMode) {
      renderMode = pendingMode;
    }
    if (renderMode === modes.cbVR) {
      // Handle cardboard resizing ourself.
      // For webVR, VREffect does it for us.
      resizeCardboard();
    }
  } else {
    if (renderMode === modes.cbVR) {
      exitCardboard();
    }
    renderMode = modes.noVR;
  }                          

}

function launchCardboard() {
  // Allow cardboard mode on all devices for easier debugging.

  pendingMode = modes.cbVR;

  // Polyfill for entering fullscreen.
  var container = document.getElementById("container");
  if (container.requestFullscreen) {
    container.requestFullscreen();
  } else if (container.mozRequestFullScreen) {
    container.mozRequestFullScreen();
  } else if (container.webkitRequestFullscreen) {
    container.webkitRequestFullscreen();
  } else if (container.msRequestFullscreen) {
    container.msRequestFullscreen();
  }

  // Special case for iOS which doesn't allow fullscreen, fake it.
  if (iOS) {
    resizeCardboard();
  }
}

function exitCardboard() {

  var width = winRenderWidth;
  var height = winRenderHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();

  renderer.setSize(width, height);
}

function resizeCardboard() {
  // If iOS we're not really running in fullscreen.
  var width = iOS ? window.innerWidth : screen.availWidth;
  var height = iOS ? window.innerHeight : screen.availHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();

  renderer.setSize(width, height);
  cbEffect.setSize(width, height);
}

function onOrientationChange() {
  if (renderMode === modes.cbVR) {
    resizeCardboard();
  }
}

//---------------------------------------------------------------------------
// Main
//---------------------------------------------------------------------------

function main() {

  initScene();
  addVRControls();
  animate();

}

// Event handlers.
document.addEventListener( 'mousedown', onMouseDown, false);
document.addEventListener( 'mouseup', onMouseUp, false);

document.addEventListener("fullscreenchange", onFullscreenChange, false);
document.addEventListener("mozfullscreenchange", onFullscreenChange, false);
document.addEventListener("webkitfullscreenchange", onFullscreenChange, false);

window.addEventListener('orientationchange', onOrientationChange);

window.addEventListener("keypress", onKeyPress, true);

window.addEventListener("load", main, false);

</script>
</html>
